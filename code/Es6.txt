ES6学习：
1、let命令
	新增了let命令，用来申明变量。
	1：所声明的变量，只在let命令所在的代码块内有效。
	2：不存在变量提升。
	// var 的情况
	console.log(foo); // 输出undefined
	var foo = 2;

	// let 的情况
	console.log(bar); // 报错ReferenceError，没有找到bar变量，没有被声明。
	let bar = 2;

	3：暂时性死区

	var tmp = 123;

	if (true) {
	  tmp = 'abc'; // ReferenceError
	  let tmp;
	}

	上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
	ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
	“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

	4：不允许重复声明：
	let不允许在相同作用域内，重复声明同一个变量。

何为变量提升：
	js引擎会在解释代码之前首先对其进行编译，编译阶段第一个工作就是找到所有的申明。
	var foo = 2;在js引擎看来就是var foo; foo = 2;这就是所谓的变量提升。


	4：块级作用域
	let实际上为 JavaScript 新增了块级作用域

	个人理解，之所以有了块级作用域，还是因为没有了变量提升。

2、const命令
	const声明一个只读的常量。一旦声明，常量的值就不能改变。
	const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
	const的作用域与let命令相同：只在声明所在的块级作用域内有效。

	const本质：const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

	const foo = {};

	// 为 foo 添加一个属性，可以成功
	foo.prop = 123;
	foo.prop // 123

	// 将 foo 指向另一个对象，就会报错
	foo = {}; // TypeError: "foo" is read-only

	上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
